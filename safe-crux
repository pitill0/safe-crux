#!/bin/bash
#
# Copyright (c) 2007 - 2012
#   Jose V Beneyto, <sepen@crux.nu>
#   Victor Martinez, <pitillo@ono.com>
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.

#
# Functions
#

msgError() {
  echo "Error, $@" 2>&1
  exit 1
}

msgVersion() {
  echo "$APPNAME v$APPVERSION by Jose V Beneyto and Victor Martinez"
  exit 0
}

msgUsage() {
  echo "Usage: $APPNAME subcommand <arguments>"
  echo "Where options are:"
  echo "  help                     Show this help information"
  echo "  version                  Show version information"
  echo "  stat                     Show status for mounted images"
  echo "  install <target|file>    Create new environment"
  echo "  use [target|file]        Use the filesystem image as the environment"
  echo "  mount [target]           Mount the selected image as the environment"
  echo "  umount [target]          Umount the environment"
  exit 0
}

checkMD5() {
  local md5_file="$1"
  cd $ISODIR && md5sum -c $1 >/dev/null 2>&1 || msgError "md5sum differs"
}

checkUID() {
  [ $(id -u) -ne 0 ] && msgError "you must be root to use $APPNAME"
}

getTarget() {
  local target=$1
  # if is not a valid path
  if [ ! -e $target ]; then
    # is is not a file under $IMGDIR
    if [ ! -f $IMGDIR/$target ]; then
      msgError "can't find $target"
    else
      target="$IMGDIR/$target"
    fi
  fi
  echo $target
}

getTargetType() {
  local target=$1
  if [ -b "$target" ]; then
    echo "block"
  elif [ -d "$target" ]; then
    echo "dir"
  elif [ -f "$target" ]; then
    echo "file"
  else
    echo "null"
  fi
}

getMountPoint() {
  local target=$1
  # use name of target as name of mount point
  echo "$MNTDIR/$(basename $target)"
}

#
# Tasks
#

createUserConf() {
    # redefine config variables
    ISODIR="$USERDIR/iso"
    MNTDIR="$USERDIR/mnt"
    IMGDIR="$USERDIR/img"
    # create dirs
    mkdir -p $ISODIR $MNTDIR $IMGDIR
    # create user config file
    cat > $USERDIR/$APPNAME.conf << __EOF__
#
# $USERDIR/$APPNAME.conf
#

# directory where iso files are stored
ISODIR=$ISODIR
# directory where safe-crux's targets are mounted
MNTDIR=$MNTDIR
# directory containing safe-crux's images
IMGDIR=$IMGDIR

# End of file
__EOF__
}

downloadISO() {
  local wget_options="-c --passive-ftp --tries=3 --waitretry=3 --directory-prefix=$ISODIR"
  local source_version="2.7.1"
  [ ! -z $SOURCE_ISO_VERSION ] && source_version="$SOURCE_ISO_VERSION"
  local source_iso="ftp://code-monkey.de/pub/crux/crux-$source_version/iso/crux-$source_version.iso"
  local source_md5="ftp://code-monkey.de/pub/crux/crux-$source_version/iso/crux-$source_version.md5"
  [ ! -z $SOURCE_ISO_FILE ] && source_iso="$SOURCE_ISO_FILE"
  [ ! -z $SOURCE_MD5_FILE ] && source_md5="$SOURCE_MD5_FILE"
  local file_iso="$ISODIR/${source_iso##*/}"
  local file_md5="$ISODIR/${source_md5##*/}"
  [ ! "$(type -p wget)" ] && msgError "command 'wget' not found"
  [ ! -f $file_iso ] && wget $wget_options $source_iso
  [ ! -f $file_md5 ] && wget $wget_options $source_md5
  echo "+ Checking md5sum ..."
  checkMD5 $file_md5
}

makeImageFile() {
  echo "+ Checking for existing images ..."
  local answer="n"
  local imgfile=$1
  if [ -f $imgfile ]; then
    read -p "File '$imgfile' found, do you want to remove it [y|n] " answer
    [ "$answer" == "y" ] && rm -vf $imgfile
  fi
  echo "+ Getting some space for the filesystem image. Please wait ..."
  local imgsize="512000" # 512M
  [ ! -z $IMAGE_SIZE ] && imgsize=$IMAGE_SIZE
  dd if=/dev/zero of=$imgfile bs=1k count=$imgsize
}

makeFileSystem() {
  echo "+ Formating ..."
  local target=$(getTarget $1)
  local target_type=$(getTargetType $target)
  # decide what to do
  case $target_type in
    file|block)
      local fstype="ext2"
      [ ! -z $IMAGE_FSTYPE ] && fstype=$IMAGE_FSTYPE
      mkfs -t $fstype -q $target
      [ $? -ne 0 ] && exit 0
      ;;
    *)
      msgError "can't format $target"
      ;;
  esac
}

#
# Commands
#

scMount() {
  echo "+ Mounting target $1 ..."
  local target=$(getTarget $1)
  local mount_point=$2
  [ -z "$mount_point" ] && mount_point=$(getMountPoint $target)
  local target_type=$(getTargetType $target)
  # decide what to do
  case $target_type in
    file)
      mkdir -p $mount_point
      mount -o loop,rw $target $mount_point
      ;;
    block)
      mkdir -p $mount_point
      mount -o rw $target $mount_point
      ;;
  esac
}

scUmount() {
  echo "+ Unmounting target $1 ..."
  local target=$(getTarget $1)
  local mount_point=$2
  [ -z "$mount_point" ] && mount_point=$(getMountPoint $target)
  umount $mount_point && rm -r $mount_point
}

scInstall() {
  local use_iso=1
  local target=$IMGDIR/crux
  [ ! -z $1 ] && target=$1
  local target_type=$(getTargetType $target)
  local mount_point=$2
  [ -z $mount_point ] && mount_point=$(getMountPoint $target)
  case $target_type in
    block|null|file)
      if [ $target_type != "block" ]; then
        # target still not exists, so we should create a new image file
        makeImageFile $target
      fi
      makeFileSystem $target
      scMount $target $mount_point && rm -r $mount_point/lost+found
      ;;
    dir)
      # we will install in a directory
      mount_point=$target
      ;;
  esac
  echo "+ Running the setup ..."
  local pkgdir
  [ ! -z $PACKAGE_DIR ] && pkgdir=$PACKAGE_DIR
  local pkgadd
  [ ! -z $PKGADD_BIN ] && pkgadd=$PKGADD_BIN
  # if both pkgdir and pkgadd are well defined we don't need to use the iso for them
  if [ ! -z $pkgdir ] && [ ! -z $pkgadd ]; then
    use_iso=0
  else
    use_iso=1
    # now we must obtain pkgdir and pkgadd from the iso
    downloadISO
    local file_iso="$ISODIR/${SOURCE_ISO_FILE##*/}"
    echo "+ Mounting the iso image ..."
    mkdir -p $ISODIR/mnt 2>/dev/null || msgError "can't create dir '$ISODIR/mnt'"
    mount -o loop,ro -t iso9660 $file_iso $ISODIR/mnt
    local pkgdir="$ISODIR/mnt/crux/core" # crux-2.2 or greater
    [ ! -d $pkgdir ] && pkgdir="$ISODIR/mnt/crux/base" # crux-2.1 or lower
    local pkgadd=$ISODIR/usr/bin/pkgadd # crux-2.3 or lower (without squasfs)
    if [ ! -f $pkgadd ]; then
      local pkgutils=$(find $pkgdir -type f -name 'pkgutils#*' -exec basename {} \;)
      case $pkgutils in
        *.xz) pkgutils=$(find $ISODIR/mnt/tools -type f -name 'pkgutils#*') ;;
      esac
      tar -C $TMPDIR -xzf $pkgutils usr/bin/pkgadd
      pkgadd=$TMPDIR/usr/bin/pkgadd
      if [ ! -f $pkgadd ]; then
        msgError "can't find pkgadd binary in '$pkgadd'"
      fi
    fi
  fi
  # call the fakesetup
  $BINDIR/fakesetup $pkgdir $mount_point --with-pkgadd=$pkgadd
  if [ $? -eq 0 ]; then
    echo "+ Installing extra stuff ..."
    install -D -m 0644 /etc/resolv.conf $mount_point/etc/resolv.conf
    install -D -m 0644 /etc/hosts $mount_point/etc/hosts
    if [ $use_iso -eq 1 ]; then
      install -D -m 0644 $ISODIR/mnt/crux/handbook.txt $mount_point/root/handbook.txt
    fi
  fi
  # umount the iso if was used 
  if [ $use_iso -eq 1 ]; then
    echo "+ Unmounting the iso image ..."
    umount $ISODIR/mnt
  fi
  # umount the target if a directory not was used
  case $target_type in
    block|null|file)
      scUmount $target $mount_point
      ;;
  esac
}

scUse() {
  local target=$(getTarget $1)
  local target_type=$(getTargetType $target)
  local chroot_shell="/usr/bin/env -i HOME=/root /bin/bash"
  # decide what to do
  case $target_type in
    dir)
      # chroot the dir
      $BINDIR/chrooted $target $chroot_shell
      ;;
    file|block)
      # obtain a mount point where target will be mounted
      local mount_point=$(getMountPoint $target)
      # mount the target
      scMount $target $mount_point
      # chroot the mount point
      $BINDIR/chrooted $mount_point $chroot_shell
      # umount the mount point
      scUmount $target $mount_point
      ;;
  esac
}

scStat() {
  sudo ps u | grep chrooted \
  | while read a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 foo; do
	[ ! -z "$a9" -a ! -z "$a13" ] && echo "$a9 $a13"
  done
}

#
# Main rutine
#

main() {
  case $1 in
    install)
      checkUID
      shift 1
      scInstall $@
      ;;
    use)
      [ $# -ne 2 ] && msgUsage
      checkUID
      shift 1
      scUse $@
      ;;
    mount)
      [ $# -ne 2 ] && msgUsage
      checkUID
      shift 1
      scMount $@
      ;;
    umount)
      [ $# -ne 2 ] && msgUsage
      checkUID
      shift 1
      scUmount $@
      ;;
    stat)
      checkUID
      scStat
      ;;
    version)
      msgVersion
      ;;
    *)
      msgUsage
      ;;
  esac
}

#
# safe-crux init
#

# environment variables
export LANG=C
export PATH=$PATH:/sbin:/usr/sbin

# static variables
readonly APPNAME="$(basename $0)"
readonly APPVERSION="2.7.3"

# variables that can be overriden by the config file
TMPDIR="$(mktemp -d)"
BASEDIR="$(cd $(dirname $0); pwd -P)" # pwd -P: avoid all symlinks
ISODIR="$BASEDIR/iso"
MNTDIR="$BASEDIR/mnt"
IMGDIR="$BASEDIR/img"
BINDIR="$BASEDIR/bin"
ETCDIR="$BASEDIR/etc"
USERDIR="$HOME/.$APPNAME"

# load config vars
[ -f $ETCDIR/$APPNAME.conf ] && . $ETCDIR/$APPNAME.conf

# load config vars overwriten by user
if [ $USERCONF -eq 1 ]; then
    # if SUDO_USER environment variable is not empty
    if [ "x$SUDO_USER" != "x" ]; then
	HOMEDIR="$(getent passwd $SUDO_USER | cut -d':' -f6)"
	USERDIR="$HOMEDIR/.$APPNAME"
	[ ! -d $USERDIR ] && createUserConf
	[ -f $USERDIR/$APPNAME.conf ] && . $USERDIR/$APPNAME.conf
    fi
fi

# handle signals
trap "msgError interrupted" SIGINT SIGTERM

# call the main rutine
main $@

# End of file
